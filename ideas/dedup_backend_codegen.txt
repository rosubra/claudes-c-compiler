LOW PRIORITY: Remaining backend codegen deduplication opportunities

Completed items:
- CastKind enum + classify_cast() extracts shared cast classification
- classify_float_binop() + FloatOp enum shares float operation dispatch
- ARM operand_to_x0 movz/movk inlining deduplicated via emit_load_imm64
- ARM emit_sub_sp/emit_add_sp simplified to use emit_load_imm64
- classify_float_binop() unwrap_or(FloatOp::Add) latent bug now panics on all 3 backends
- ARM emit_va_start/emit_va_copy/emit_va_arg large-offset bug fixed
- SignedToUnsignedSameSize cast now properly masks sub-word types on ARM and RISC-V
- Default trait implementations for simple methods: emit_branch, emit_cond_branch,
  emit_unreachable, emit_indirect_branch, emit_label_addr, emit_va_end, emit_copy_i128.
  Each backend provides small primitives (jump_mnemonic, trap_instruction,
  emit_branch_nonzero, emit_jump_indirect) and the defaults compose them.
- emit_cast_instrs promoted to trait method; default emit_cast does load→cast→store.
  x86-64 overrides emit_cast for 128-bit widening/narrowing. ARM and RISC-V use default.
- emit_binop decomposed: default dispatches float→emit_float_binop, int→emit_int_binop.
  x86-64 overrides emit_binop for 128-bit integer arithmetic.
  Each backend provides arch-specific emit_float_binop and emit_int_binop.

Remaining opportunities (diminishing returns):

1. Parameter classification: emit_store_params and emit_call all independently classify
   params as int-reg/float-reg/stack. A shared classify_params() helper could reduce this,
   but the three ABIs differ significantly (x86-64 SysV, AAPCS64, RISC-V LP64D), so the
   benefit is lower.

2. emit_memcpy: ARM and RISC-V share the same loop algorithm but differ in addressing
   modes (ARM post-increment vs RISC-V explicit pointer advance). x86 uses rep movsb.
   The savings are marginal (~10 lines) since the loop bodies are structurally different.

3. emit_inline_asm: All three backends share a 4-phase operand handling framework
   (assign registers, handle + constraints, load inputs, substitute template).
   A shared framework could save ~100 lines, but the register constraint classification
   is deeply arch-specific. Medium effort, medium reward.
