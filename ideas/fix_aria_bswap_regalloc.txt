Fix ARIA bswap register allocator conflict (mbedtls 7/7)
========================================================

Bug: mbedtls ARIA-ECB-128 encryption selftest fails.

The ARIA cipher uses this macro chain:
  #define ARIA_P2(x) (((x) >> 16) ^ ((x) << 16))
  #define ARIA_P3(x) __builtin_bswap32(x)
  #define ARIA_P1(x) ARIA_P2(ARIA_P3(x))

ARIA_P1(x) expands to:
  ((__builtin_bswap32(x)) >> 16) ^ ((__builtin_bswap32(x)) << 16)

This evaluates __builtin_bswap32(x) twice. After the GVN optimization
pass merges the duplicate bswap calls into a single value, the register
allocator assigns the bswap result to a callee-saved register (e.g., rbx)
that overlaps with the input variable's live interval.

The generated assembly looks like:
  movq %rax, %rbx     ; rbx = input value (callee-saved, still live)
  bswapl %eax          ; eax = bswap(input) -- correct
  movq %rax, %rbx      ; rbx = bswap result, OVERWRITES original input
  bswapl %eax          ; eax = bswap(bswap(input)) = input -- WRONG
                        ; Should have been bswap(input) again

The second bswap undoes the first because the original input was
overwritten before the second bswap could use it.

This is a register allocator liveness analysis issue: two values with
overlapping live ranges are assigned the same physical register.

Possible fixes:
1. Fix the linear scan allocator to detect live range conflicts when
   assigning callee-saved registers to bswap/similar intrinsic results
2. Improve spill logic so overlapping intervals get different registers
3. Add a post-GVN pass that detects when merged values create
   conflicting liveness requirements

Test case: /tmp/test_p1.c (ARIA_P1 macro with 0x01020304 input)
Expected result: 0x02010403
Actual result: incorrect due to register conflict

Impact: Fixing this would make mbedtls fully pass (7/7 tests).
