LOW PRIORITY: Add structured error infrastructure (DiagnosticEngine)

Current state (partially addressed):
- Parser errors now include file:line:col via SourceManager + preprocessor line markers
- Preprocessor emits GCC-style # linenum "filename" markers at #include boundaries
- SourceManager builds a line map from these markers for span resolution
- SourceManager::get_source_line() is ready for snippet rendering

Remaining patterns still using bare eprintln! without structured diagnostics:
1. Parser: still uses eprintln! (now with location prefix) + manual error_count
2. Sema: eprintln! immediately + push to Vec<String> that nobody reads
3. Preprocessor: #error pushed to Vec<String>; #warning to eprintln!
4. IR lowering: standalone eprintln! with no buffering

What to do (incremental):
1. Create a DiagnosticEngine in common/ -- Diagnostic with severity, message, span,
   optional notes. Support emit(), print_all(), has_errors(), error_count().
2. Wire it into the driver -- create one instance, thread it through each phase
3. Have the parser emit Diagnostics instead of eprintln! (locations already work)
4. Have sema emit Diagnostics instead of eprintln! + warnings Vec
5. Have the preprocessor report errors through DiagnosticEngine
6. Have the driver check for errors after each phase and print_all at the end
7. Add source-snippet rendering to Diagnostic::emit() -- extract the source line
   from SourceManager (get_source_line is ready), print a caret/underline under span

Key files:
- src/common/source.rs (SourceManager with line map, get_source_line for snippets)
- src/frontend/parser/parser.rs (eprintln! with location prefix)
- src/frontend/sema/sema.rs (eprintln! + warnings Vec)
- src/frontend/preprocessor/preprocessor.rs (errors Vec, eprintln! for #warning)
- src/driver/driver.rs (creates SourceManager, passes to parser)
