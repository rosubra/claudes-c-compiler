Include Guard Detection for Preprocessor Speed
================================================
Priority: HIGH

Problem:
  The preprocessor re-reads and re-processes header files every time they are
  #included, even when the file has a classic include guard pattern:
    #ifndef FOO_H
    #define FOO_H
    ...
    #endif

  For the Linux kernel, each translation unit includes hundreds of headers,
  many of which include the same sub-headers repeatedly. Without include guard
  detection, the preprocessor reads, scans, comment-strips, and processes
  these files redundantly.

  Currently only #pragma once prevents re-processing. Many kernel headers
  use traditional include guards, not #pragma once.

Proposed Solution:
  After preprocessing an included file, detect if the entire file content
  is wrapped in a single #ifndef/#define/#endif guard pattern:
  1. Check if the first non-blank directive is #ifndef <MACRO>
  2. Check if the next directive is #define <MACRO> (same macro)
  3. Check if the last directive is #endif (matching the outer #ifndef)
  4. If all three match, record <MACRO> as the guard macro for this file path

  On subsequent #include of the same file:
  - If the guard macro is still defined, skip re-processing entirely
  - If the guard macro was #undef'd, re-process normally

  This is the same optimization GCC and Clang implement.

Impact:
  Could reduce preprocessing time by 30-50% for kernel compilation,
  as many headers are included dozens of times across the translation unit.

Key files:
  - src/frontend/preprocessor/includes.rs
  - src/frontend/preprocessor/preprocessor.rs
