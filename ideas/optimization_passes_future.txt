Future optimization passes to implement:

Note: SSA is now implemented. These passes can proceed.

The following passes are implemented and working:
- Constant folding (constant_fold.rs)
- Copy propagation (copy_prop.rs)
- Dead code elimination (dce.rs)
- Local value numbering / CSE (gvn.rs)
- Algebraic simplification + strength reduction (simplify.rs)
  - Includes: mul/div/rem by power-of-2 -> shift/and,
    redundant Cast elimination, GEP zero-offset elimination
- x86-64 peephole optimizer (peephole.rs in backend/x86/codegen/)

Next passes to add:
1. LICM (Loop Invariant Code Motion): Move loop-invariant computations out
   of loops. Requires loop detection (natural loops via dominators + back edges).

2. Function inlining: For small functions, inline the callee body at call sites.
   Start with leaf functions < N instructions.

3. Dominator-based GVN: Extend current local GVN to cross basic block boundaries
   using a dominator tree. This enables more CSE opportunities.

4. Constant propagation (SCCP): Sparse conditional constant propagation -
   propagate constants through the CFG, taking branch conditions into account.

5. Strength reduction in loops: Replace expensive operations (mul) with
   cheaper ones (add) for loop induction variables.

Priority: MEDIUM (existing passes handle the most impactful cases)
