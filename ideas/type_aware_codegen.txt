Type-Aware Code Generation

Current problem:
All backends use 8-byte (64-bit) operations for every value regardless of type.
This means:
- int arrays waste 2x memory (8 bytes per element instead of 4)
- char arrays waste 8x memory
- int operations that should use 32-bit instructions use 64-bit
- Values wider than the actual type may produce incorrect results
  (e.g., sign extension issues, upper bits not zeroed)
- Comparison operations may behave incorrectly for unsigned types

Proposed fix:
1. Thread IrType through all Load/Store instructions properly
2. Generate type-appropriate instructions:
   - x86: movb/movw/movl/movq based on IrType (I8/I16/I32/I64)
   - ARM: strb/strh/str w/str x and ldrb/ldrh/ldr w/ldr x
   - RISC-V: sb/sh/sw/sd and lb/lh/lw/ld
3. Allocate correct stack space per type (not always 8 bytes)
4. Handle sign/zero extension on loads of smaller types
5. Use 32-bit arithmetic for int operations (addw, subw on RISC-V)

This is critical for correctness and will significantly improve the
pass rate on the test suite, especially for array-heavy programs
and programs that depend on char/short semantics.

Priority: HIGH
Impact: Would likely improve pass rate by 5-10% across all targets.
