Idea: Fix pointer array and function pointer type handling in compute_decl_info

Priority: HIGH (affects many tests)

Problem:
1. Array of pointers (e.g., `int *ptrs[3]`) is misclassified by compute_decl_info.
   The derived declarators [Pointer, Array(3)] trigger the `has_pointer && has_array`
   branch which returns (8, elem_size, false, true, []) - treating it as a single
   pointer rather than an array of 3 pointers.

   Result: alloc_size=8 (should be 24), is_array=false (should be true),
   elem_size wrong.

2. Function pointer globals called through the variable name are treated as
   direct function calls. E.g., `int (*fp)(int,int) = add; fp(1,2)` generates
   `call fp` instead of loading fp's value and doing an indirect call.
   This affects the lowering of function calls on identifiers that are in
   known_functions but also have a global variable definition.

3. The string array pattern `const char *strs[] = {"a", "b"}` similarly needs
   correct pointer array handling to get the right alloc_size and element count.

Fix approach:
- For (1): compute_decl_info needs to distinguish between `int *arr[N]` (array of
  pointers, where Pointer is "inner" and Array is "outer") vs `int (*p)[N]` (pointer
  to array, where Array is "inner" and Pointer is "outer"). In C declarator syntax,
  the order matters based on precedence: `int *arr[N]` parses as `(int*) arr[N]`.

- For (2): When lowering a FunctionCall(Identifier(name)), if name is both in
  known_functions AND in globals (as a function pointer variable), it should be
  treated as an indirect call through the global.

- For (3): Once (1) is fixed, string arrays will naturally get correct sizing.

Impact: Would fix ~50+ additional tests that use pointer arrays or function pointer
globals called through variables.
