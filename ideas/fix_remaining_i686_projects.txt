Fix remaining i686 project failures
=====================================
Date: 2026-01-29 (updated after narrow pass comparison fix)

Current status:
- Unit tests: 99.85% pass (27183/27361) - up from 99.8%
- Standard projects (run_all_verify): 12/12 pass
  (zlib, lua, mquickjs, libpng, jq, libjpeg, libuv, libsodium, mbedtls, libffi, musl + redis*, tcc*)
  * redis: passes (tested separately, not in standard run)
  * tcc: build succeeds; test suite fails due to missing i686 CRT/headers (same as GCC)
- sqlite: 622/622 pass (was 195/622, now fully fixed)
- postgres: build fails (linker error, R_386_GOTOFF relocation / shared lib)
- Latest fix: narrow pass comparison constant truncation (9 unsigned/cast tests fixed)

Fixed (i128 store register clobber on i686):
- emit_store_default i128 Indirect path clobbered callee-saved registers (esi/edi)
  before loading the destination pointer, destroying it when register-allocated
  to esi or edi. This caused SIGSEGV in libsodium's Ed25519 crypto_sign operations.
  - Root cause: In traits.rs emit_store_default(), the sequence was:
    emit_load_acc_pair -> emit_save_acc_pair -> emit_load_ptr_from_slot
    emit_save_acc_pair moves eax->esi, edx->edi, clobbering the pointer.
  - Fix: Reorder to load pointer before save_acc_pair:
    emit_load_acc_pair -> emit_load_ptr_from_slot -> emit_save_acc_pair
  - Fixes libsodium sign/box (was SIGSEGV, now 7/7 pass)
  - No regressions on any target

Fixed (mode(TI) and __int128 rejection on i686):
- CCC-i686 silently accepted mode(TI) and __int128 on 32-bit targets
  - GCC i686 correctly rejects these ("unable to emulate 'TI'")
  - libsodium configure detected 128-bit support and used fe_51 (64-bit field elements)
    instead of fe_25_5 (32-bit field elements), generating broken code
  - Fix: reject mode(TI) and __int128/__uint128_t on 32-bit targets
  - Also fixed mode(word)/mode(pointer) to map to SI (32-bit) on i686 instead of DI (64-bit)
  - libsodium: 7/7 tests now pass (was 5/7)

Fixed in latest round (bitfield I32 ops fix):
- Bitfield extract/store operations used hardcoded IrType::I64 for all shift/mask ops
  - Root cause: truncate_to_bitfield_value, store_bitfield, store_bitfield_split,
    extract_bitfield, extract_bitfield_from_addr in src/ir/lowering/expr_assign.rs
    all used IrType::I64 and 64-bit shift amounts unconditionally.
  - On i686, this generated shrdl/shldl (64-bit shift pairs) that read eax:edx,
    but loaded 32-bit values only populated eax, leaving edx uninitialized.
  - Fix: Use widened_op_type(storage_ty) → I32 on i686, I64 on 64-bit targets.
  - Fixes bitfield corruption in structs like mquickjs JSString (uint32_t with
    len:25, is_ascii:1, etc. bitfields).
  - No regressions: x86-64 99.8%, ARM 99.7%, RISC-V 100.0%, i686 99.7%
  - Note: mquickjs still fails due to separate ROM table mismatch (see below)

Previously fixed (LogicalNot 64-bit fix):
- LogicalNot (!) on 64-bit values was truncating to 32 bits on i686
  - Root cause: UnaryOp::LogicalNot in src/ir/lowering/expr_ops.rs used
    target_int_ir_type() (I32 on i686) as the comparison type for ALL values,
    including I64/U64. Values like 0x100000000ULL were incorrectly treated as zero.
  - Fix: Use inner expression's type for comparison when it is a wide integer
    (I64/U64) wider than target int. Float types excluded since
    mask_float_sign_for_truthiness already reduces them to I32 booleans.
  - Fixes comk3114 test (64-bit shift loop with `!i` condition)
  - libjpeg now 2/2 (was 1/2 before)
  - i686 unit test pass rate improved from ~99.2% to 99.7%
  - No regressions on x86-64 (99.9%), ARM (99.6%), RISC-V (99.9%)

Fixed (Redis i686 fix):
- PIC global address: emit_global_addr used GOT-relative %ebx addressing without
  setting up %ebx; switched to absolute addressing since we link with -no-pie
- mem2reg constant narrowing: I64 constants stored into 32-bit allocas caused
  phi-elimination to use 64-bit copies, leaving upper 32 bits uninitialized
- Added IrConst::narrowed_to() to narrow constants to match alloca type in mem2reg
- Redis: now fully passes on i686 (build + SET/GET + cli)

Previously fixed (Copy I64 const wide marking fix):
- tcc BUILD now succeeds (was failing in alloca86_64.S assembly)
- libjpeg fully passes (was "Bogus virtual array access")

Previously fixed (inline asm typed register load fix):
- libsodium now BUILDS (was failing with "operand size mismatch for `movzw'")

Fixed (inline asm "g" constraint register conflict):
- musl: All 6/6 tests now pass on i686 (was 3/6)
  - Root cause: On i686 with only 6 GP registers, __syscall6() uses all 6 via
    specific constraints ("a", "b", "c", "d", "S", "D"). The 7th operand with "g"
    constraint was assigned eax (conflicting with "a"), overwriting the syscall
    number. mmap2 (0xc0) became restart_syscall (0), causing malloc to fail.
  - Fix: When assign_scratch_reg exhausts all GP registers and the constraint has
    a memory alternative (like "g"), fall back to AsmOperandKind::Memory and emit
    the value's stack slot offset directly (e.g., -8(%ebp)) as the operand.
  - This fixed malloc, io (tmpfile), and environ (setenv/getenv) which all depend
    on mmap2 via musl's malloc.

Fixed (narrow pass comparison constant truncation):
- The narrow optimization pass (passes/narrow.rs Phase 6) incorrectly narrowed
  Cmp instructions when one operand was zero-extended from U32 to U64 and the
  other was an I64 constant with non-zero upper 32 bits.
  - Example: Cmp(Eq, zext(x:U32), I64(-10)) narrowed to Cmp(Eq, x, U32(0xFFFFFFF6))
    but I64(-10) is 0xFFFFFFFF_FFFFFFF6, and truncating the constant to U32 loses
    the upper 0xFFFFFFFF bits. This caused false equality when comparing
    unsigned long (32-bit on i686) with unsigned long long constants.
  - Fix: Added try_narrow_const_for_cmp() that requires value preservation through
    zero/sign extension round-trip. For U32, only non-negative constants (0..u32::MAX)
    are narrowable; for I32, only i32::MIN..i32::MAX.
  - Fixes 9 unit tests (unsigned arithmetic, cast round-trips, pointer-int casts,
    constant folding of unsigned long operations).
  - No regressions on any target.

Known remaining issues:

1. sqlite: FIXED — 622/622 tests pass

2. mquickjs: FIXED — all 5 tests pass

3. libsodium: FIXED - 7/7 tests pass

4. mbedtls: FIXED - 7/7 tests pass (was 5/7)

5. libffi: FIXED - all 6/6 tests pass

6. postgres: Build fails - linker error (R_386_GOTOFF relocation / shared lib issue)
   - dict_snowball.so link fails
   - May be related to PIC/shared library handling on i686

7. tcc: FIXED - 76/78 tests pass (was 1/78)
   - Fixed by creating i386 sysroot symlinks and uname wrapper for configure detection
   - Run `sudo scripts/setup_i686_cross.sh ~/.cargo/bin` to set up environment
   - Remaining 2 failures (95_bitfields, 95_bitfields_ms) are arch-specific expected-value
     mismatches: test .expect files have 64-bit formatting, but 32-bit TCC uses sizeof(long)=4

Remaining unit test failures (41/27361 = 0.15%):
- FP classification (fpclassify/nan/infinity edge cases)
- Vector extensions (scal_to_vec, simd operations)
- Some cast edge cases and qualified type handling
- One execution timeout (uint64_to_float)

Priority investigation targets:
- postgres build: PIC/shared library linker support on i686
- Remaining unit test failures: mostly FP edge cases and vector extensions
