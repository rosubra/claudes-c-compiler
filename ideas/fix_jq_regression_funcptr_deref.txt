Fix jq remaining segfaults (9 of 12 tests still fail with SIGSEGV)

Status: 3 tests now pass (--version, .a, {x:.a, y:.b}) after fixing
the struct member array subscript stride bug (commit fix_member_array_subscript_stride).
The original SIGABRT from hash table corruption is fixed. The remaining 9 failures
are SIGSEGV in more complex jq operations (add, interpolation, regex, map/select,
keys, group_by, recursive descent, try-catch, reduce).

The original theory about typedef'd function pointer dereference was partially wrong.
The root cause of the SIGABRT was that get_member_array_elem_size() in lvalue.rs
called elem_ty.size() on struct CTypes which returns 0 (since CType::Struct only
stores a key). This made all flexible array member subscripts (obj->elements[i])
compute offset 0, corrupting jq's hash table buckets.

Remaining SIGSEGV issues to investigate:
1. Nested typedef function pointer dereference: `typedef op_func my_op; (*mop)(10)`
   crashes because my_op isn't tracked in func_ptr_typedefs (need transitive typedef
   propagation for function pointer typedefs)
2. There may be additional codegen issues in jq's bytecode interpreter (execute.c)
   which uses complex struct-heavy control flow, computed gotos (switch-heavy dispatch),
   and function pointer callbacks

To investigate:
1. Use the bisection approach (build baseline with gcc, replace one .o at a time with
   ccc) to find which miscompiled .c file(s) cause the remaining segfaults
2. Fix nested typedef function pointer tracking in stmt.rs and lowering.rs typedef
   processing (check if base type_spec resolves to a known func_ptr_typedef and
   propagate the func_ptr_typedef_info entry)

Priority: MEDIUM - partially fixed, remaining issues are separate bugs.
