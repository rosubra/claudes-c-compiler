HIGH PRIORITY: Expand sema to produce a typed AST, reducing lowering responsibilities

Current state (after Steps 1-5 complete):
The sema pass collects type information (typedefs, struct layouts, enum constants,
function signatures), has ExprTypeChecker for CType inference, annotates every
analyzable expression with its CType via ExprTypeMap, and now pre-computes
compile-time constant values via SemaConstEval into a ConstMap. The lowerer
receives all three maps and uses them as fast O(1) fallbacks. It does NOT yet:
- Reject type errors with diagnostics
- Replace the lowerer's expr_types.rs entirely (lowerer still needs its own
  get_expr_ctype_lowerer for lowering-specific state like locals/globals)
- Fully eliminate lowerer's const_eval (lowerer still has its own for global
  address expressions and func_state const local lookups)

The lowerer (ir/lowering/) is ~18K lines and handles both type inference AND IR
emission. Key type-inference code that should move to sema:

1. Expression type inference (expr_types.rs, ~1200 lines)
   - get_expr_type(): determines IrType of any expression
   - get_expr_ctype(): determines CType of any expression using lowering state
   - struct_value_size(): checks if expression produces struct value
   The lowerer's version needs locals/globals; sema's ExprTypeChecker uses
   SymbolTable instead. As sema's type tracking becomes complete, the lowerer
   can delegate more to sema.

2. Constant expression evaluation (const_eval.rs, 969 lines)
   PARTIALLY UNIFIED. Sema now has SemaConstEval (const_eval.rs) returning
   IrConst with: float literals, cast chains, sizeof/alignof, binary ops with
   proper signedness, offsetof patterns. The lowerer's eval_const_expr uses
   sema's ConstMap as an O(1) fast path. Lowerer still handles: global address
   expressions, func_state const local values, pointer arithmetic on globals.
   TODO: move more of these to sema as sema gains more scope tracking.

3. Type conversion duplication (DONE - unified via TypeConvertContext trait)
   The type_spec_to_ctype dispatch was unified into type_builder.rs.

4. C type arithmetic (DONE - moved to CType methods)
   usual_arithmetic_conversion(), integer_rank(), is_unsigned() are now CType
   methods in common/types.rs, shared by both sema and lowering.

5. Declaration analysis (lowering.rs analyze_declaration, ~200 lines)
   Computes DeclAnalysis from type specifiers. This is type analysis, not IR.

Incremental approach:
Step 1: (DONE) Move TypeContext to sema/type_context.rs
Step 2: (DONE) Add ExprTypeChecker in sema/type_checker.rs with infer_expr_ctype()
        - CType arithmetic (usual_arithmetic_conversion etc.) moved to CType methods
        - ExprTypeChecker uses SymbolTable + TypeContext + FunctionInfo
        - Sema now resolves typeof(expr) via ExprTypeChecker
Step 2.5: (DONE) Pass sema function signatures to lowerer
        - Lowerer receives FxHashMap<String, FunctionInfo> from SemaResult
        - Pre-populates known_functions from sema's function map
        - Uses sema's return CType as source-of-truth in register_function_meta
        - Falls back to sema function info in get_expr_ctype, get_call_return_type,
          get_function_return_ctype for function return type resolution
        - Eliminates redundant type_spec_to_ctype calls in register_function_meta
Step 3: (DONE) Have sema annotate expressions with CTypes during its walk
        - Added ExprTypeMap (FxHashMap<usize, CType>) to SemaResult
        - Uses raw pointer address of Expr nodes as stable key (AST is immutable)
        - Sema's analyze_expr() calls ExprTypeChecker::infer_expr_ctype() for each
          expression and stores results in expr_types map
        - ExprTypeMap type exported from sema module
Step 4: (DONE) Have lowerer consume sema's type annotations instead of re-computing
        - Lowerer receives ExprTypeMap in with_type_context() constructor
        - get_expr_ctype() now tries lowerer-specific inference first, then falls
          back to sema's pre-computed annotations via lookup_sema_expr_type()
        - Original logic moved to get_expr_ctype_lowerer() internal method
        - Zero regressions across all three backends (x86, ARM, RISC-V)
Step 5: (DONE) Expand sema const_eval to produce IrConst values
        - Added SemaConstEval in sema/const_eval.rs returning Option<IrConst>
        - Handles: float literals (F32, F64, LongDouble), cast chains with
          bit-width tracking, binary ops with type-aware signedness, sizeof/alignof
          via sema's type resolution, ternary conditionals, offsetof patterns,
          __builtin_types_compatible_p
        - Added ConstMap (FxHashMap<usize, IrConst>) to SemaResult
        - Sema's analyze_expr() populates ConstMap via annotate_const_value()
        - Sema's eval_const_expr() now delegates to SemaConstEval (removed 190
          lines of duplicated sizeof_type_spec/alignof_type_spec from sema.rs)
        - Lowerer's eval_const_expr() uses sema ConstMap as O(1) fast path
        - Zero regressions across all three backends (x86, ARM, RISC-V)
Step 5.5: (DONE) Unify shared const_eval arithmetic into common/const_arith.rs
        - Extracted eval_const_binop, eval_const_binop_float, negate_const,
          bitnot_const, truncate_and_extend_bits, is_zero_expr into shared module
        - Both sema::const_eval and lowering::const_eval delegate to shared functions
        - Type checker's eval_const_expr now delegates to SemaConstEval (resolved TODO)
        - Eliminated ~167 lines of duplicated code across 3 modules
        - Removed unused SemaResult.warnings Vec, dead driver parse error check,
          duplicated implicit declaration warning in lowerer
        - Zero regressions across all three backends (x86, ARM, RISC-V)
Step 5.6: (DONE) Extract shared const_eval functions into common/const_eval.rs
        - Extracted eval_literal, eval_builtin_call (14 builtins), promote_sub_int,
          irconst_to_bits, eval_binop_with_types into common/const_eval.rs
        - Both sema::const_eval and lowering::const_eval delegate to shared functions
        - Eliminated ~400 lines of near-identical code (literals, builtins, promotion,
          binop wrapper)
        - Zero regressions across all three backends (x86, ARM, RISC-V)
Step 6: Add actual type error diagnostics in sema
Step 7: Simplify lowering to assume types are correct

Benefits:
- Type errors become diagnostics instead of IR lowering panics
- Lowering shrinks from ~18K to ~12K lines
- Clearer module boundary: sema validates, lowering emits
- Enables future type-system features (generics, better error messages)

Key files:
- src/frontend/sema/sema.rs (current sema pass)
- src/frontend/sema/type_context.rs (TypeContext, in sema)
- src/frontend/sema/type_checker.rs (ExprTypeChecker for CType inference)
- src/frontend/sema/const_eval.rs (SemaConstEval for IrConst evaluation)
- src/common/types.rs (CType methods: usual_arithmetic_conversion, integer_rank, etc.)
- src/ir/lowering/expr_types.rs (~1200 lines of type inference, partially shared now)
- src/ir/lowering/const_eval.rs (969 lines of const eval, now with sema fast path)
- src/ir/lowering/lowering.rs (analyze_declaration to move; consumes sema functions + consts)
