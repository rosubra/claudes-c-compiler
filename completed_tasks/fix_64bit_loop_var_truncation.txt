Task: Fix 64-bit loop variable truncation on i686
Status: completed

Root cause: In stack_layout.rs, when a ParamRef instruction for a 64-bit
parameter (U64/I64/F64) reused its alloca's stack slot (an optimization to
save frame space), the value was not being tracked in the wide_values set.
This caused downstream Copy instructions to use the 32-bit copy path instead
of the 64-bit copy path, zeroing the high 32 bits of the value.

The bug manifested when a U64 parameter was used as a loop counter modified
inside the loop body. After mem2reg promoted the parameter alloca to SSA,
phi elimination inserted a Copy from the ParamRef value to the phi dest.
Without wide tracking, only the low 32 bits were copied, making the loop
condition immediately false for values > 2^32.

This broke musl's fmt_u() function (used by printf to format uintmax_t values),
causing the musl math test to fail on i686 with incorrect output
(big=3567587328 instead of big=1000000000000).

Fix: Added wide_values/i128_values tracking to the ParamRef alloca-reuse
fast path in classify_instructions(), matching the tracking already done
in the classify_value() fallback path.

Files changed:
- src/backend/stack_layout.rs: Added type tracking for ParamRef alloca reuse
- tests/i686-paramref-u64-wide-tracking/: New regression test
