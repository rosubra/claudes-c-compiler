Task: Fix complex ternary type mismatch

Bug: Ternary operator with mismatched complex types (e.g., _Complex float vs _Complex long double)
produces garbage values. When the two branches have different complex types, neither branch
converts its value to the common complex type, so the consumer reads the wrong amount of data.

Example:
  _Complex float cf = 123.0f + 456.0fi;
  _Complex long double cl = 789.0L + 101112.0Li;
  _Complex long double result = (cond ? cf : cl);
  // When cond is false, result is garbage instead of cl's value

Root cause: In lower_conditional() in expr_ops.rs, when result_is_complex is true,
the code passes branch values through without converting them to the common complex type.
Both branches produce Ptr values, but the pointed-to data may be different sizes.

Fix: When both branches are complex but have different CTypes, convert each branch's
value to the common complex type (using convert_to_complex / common_complex_type).
