Fix 128-bit constant evaluation arithmetic

Bug: Constant expressions involving __int128 / unsigned __int128 are
evaluated using 64-bit arithmetic, silently truncating values. This causes
(u128)5 << 64 to evaluate to 5 instead of 5<<64 (high 64 bits lost).

Root causes:
1. eval_const_binop() in const_arith.rs calls to_i64() on I128 operands,
   truncating to 64 bits. No 128-bit arithmetic path exists.
2. bits_to_irconst() in sema/const_eval.rs returns IrConst::I64 for
   size-16 types instead of IrConst::I128.
3. The lowerer's const_eval cast handler lacks IrType::I128/U128 arms.

Fix plan:
- Add eval_const_binop_i128() in const_arith.rs for native i128 arithmetic
- Fix bits_to_irconst() to produce IrConst::I128 for int128 types
- Add I128/U128 arms in the lowerer's cast handler
- Fix 4+ failing regression tests: i128-binop-non-i128-operand,
  int128-func-call, 128bit-compound-assign, int128-compound-assign
