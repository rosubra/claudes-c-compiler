Task: Fix always_inline functions not being inlined when caller is too large

The inliner skips all call sites (including always_inline) when the first
call site in a large caller is a non-always_inline function. The break
statement at line 162 exits the entire loop instead of continuing to find
always_inline call sites.

This causes kernel boot failures when always_inline functions in .text
reference __initconst data that should only be accessed from .init.text.
Specifically, intel_pmu_init_hybrid (always_inline) was not being inlined
into intel_pmu_init (.init.text), causing a section mismatch.

Fix: Change the caller-too-large check from breaking to skipping, and
iterate through call sites to find eligible always_inline ones.
Also raise MAX_ALWAYS_INLINE_INSTRUCTIONS from 150 to 500 to match GCC's
behavior of always inlining __attribute__((always_inline)) functions.
