Task: Fix inline asm "i" constraint emitting register instead of immediate

Problem: When a pure "i" (immediate) constraint in inline asm can't be evaluated
at compile time (e.g., in static inline functions with parameter-dependent expressions
like `1 << (nr & 7)`), the compiler falls back to putting the value in a register.
This produces invalid assembly like `testb %edx, (%r11)` instead of `testb $imm, (%r11)`.

This affects many kernel files that use `constant_test_bit_acquire()` and similar
static inline bitops functions from arch/x86/include/asm/bitops.h.

Fix: When a pure immediate constraint (no register/memory alternatives) can't produce
a compile-time constant, emit a placeholder immediate ($0) instead of falling back to
a register. This produces valid assembly for standalone function bodies that would only
ever be called with constant arguments (after inlining, which GCC performs but we don't yet).

Status: In progress
