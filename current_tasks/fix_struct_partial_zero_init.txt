Fix incomplete zero-initialization of local structs with partial initializer lists

Bug: When a struct containing an array member is initialized with = {0},
only the first scalar element is stored. The remaining array elements are
left as garbage from the stack. E.g.:
    struct s { int arr[8]; };
    struct s x = {0}; // arr[1..7] contain garbage

Root cause: lower_struct_init_list checks items.len() < layout.fields.len()
to decide whether to zero the entire allocation. But {0} provides 1 item
for 1 field (the array), so the condition is false and no zeroing occurs.
The flat-init loop then only stores the 1 explicit value.

Fix: Always zero-initialize the entire struct allocation before writing
explicit initializer values, matching C standard semantics (C11 6.7.9p21).

Status: LOCKED
