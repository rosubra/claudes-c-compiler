Fix complex-to-bool conversion in function call arguments

Bug: When a _Complex long double value is implicitly converted to _Bool for a
function call argument, the compiler correctly converts the value (comparing
real and imaginary parts to zero) but then incorrectly treats the resulting
boolean value as a 32-byte struct when passing it to the callee.

Root cause: In lower_call_arguments (expr_calls.rs), the struct_arg_sizes
vector is built from original argument expressions' CTypes (Stage B), not from
the already-converted argument types (Stage A). When a ComplexLongDouble arg is
converted to _Bool in Stage A, Stage B still sees ComplexLongDouble and sets
struct_arg_sizes to Some(32). The backend then treats the 1-byte boolean value
as a pointer to 32 bytes of struct data, causing a segfault.

Fix: Check arg_types (from Stage A) before inferring struct_arg_sizes from the
original expression. If the arg was already converted to a scalar type, skip
the complex struct size inference.

Affected tests: compiler_suite_0032_0431 through 0443, compiler_suite_0147_0042,
compiler_suite_0028_0495/0496/0497, and others.
