Fix RISC-V far jump relocation overflow for large functions.

The RISC-V backend emits `j <label>` for unconditional branches, which assembles
to a JAL instruction with only ±1MB range. For large functions (e.g., oniguruma's
match_at in jq), this causes R_RISCV_JAL relocation overflow at link time.

The GNU assembler does NOT automatically relax `j` (JAL) to a longer sequence,
but it DOES relax B-type conditional branches (bnez/beqz etc.) by inverting and
inserting a j. So conditional branches are fine, but unconditional jumps overflow.

Fix: Replace `j <label>` with `jump <label>, t6` in the RISC-V backend.
The `jump` pseudo-instruction generates `auipc t6, ... ; jr t6` which has
full 32-bit (±2GB) range. The t6 register (x31) is a caller-saved temp.
