Fix ARM i128 shift-by-zero bug

Bug: In the ARM backend, i128 shift operations (Shl, LShr, AShr) jump to the
"done" label when shift amount is zero (cbz x4, done), but x0:x1 (result
registers) have not been set from x2:x3 (input registers). This means shifting
a 128-bit value by 0 produces undefined results.

RISC-V correctly handles this with an explicit "noop" label that copies input
to output registers before reaching "done".

Fix: Add mov x0, x2 / mov x1, x3 to the shift-by-zero path for all three
shift operations (Shl, LShr, AShr).

Also adding a regression test to prevent this from recurring.
