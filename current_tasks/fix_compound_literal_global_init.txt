Task: Fix compound literal array initialization in global/static initializers
Status: in_progress
Started: 2026-01-31

Problem:
Compound literal arrays used as initializers for pointer fields in static/global
structs (or as direct initializers of global pointer variables) were not generating
proper anonymous global storage. This caused:
1. Pointer fields initialized with compound literal arrays to be NULL (struct case)
2. Compound literal data to be inlined into the pointer variable's storage (pointer case)
3. Array compound literals to only emit the first element due to alloc_size using
   the element struct layout size instead of the full array size

Root Cause:
Three bugs in the global initializer lowering:
1. field_init_has_addr_refs() didn't detect bare CompoundLiteral expressions on
   pointer fields, causing struct init to take the byte serialization path (which
   can't create anonymous globals).
2. emit_compound_field_init() unwrapped compound literals without checking if the
   target field is a pointer (should create anonymous global for array-to-pointer decay).
3. create_compound_literal_global() used the element type's struct layout size for
   the allocation instead of the computed array size (elem_size * num_elems).
4. lower_compound_literal_init() had an overly restrictive check (struct_layout.is_none())
   that prevented pointer-to-struct variables from being recognized as pointer targets.

Impact:
This bug caused QEMU's builtin_x86_defs array to have broken CPU version lists,
leading to the "Registering 'YongFeng-v1-x86_64-cpu' which already exists" crash.

Files Modified:
- src/ir/lowering/global_init.rs
- src/ir/lowering/global_init_compound_struct.rs
