Fix: Sema sizeof of unsized struct arrays returns wrong value

Problem:
sizeof(cases) / sizeof(cases[0]) evaluates to 21 instead of 3 when:
  PT cases[] = { flat initializer with 21 items filling 3 structs };

Root cause:
The sema pass evaluates sizeof(cases) BEFORE the lowerer sizes the unsized array.
Sema's const eval computes sizeof(cases) as 1176 (21 items * 56 bytes per struct),
treating each flat initializer item as a separate array element. The lowerer's
eval_const_expr then uses this pre-computed value from sema_const_values (line 34
of const_eval.rs) instead of recomputing with the correct array size.

The issue is in the sema pass: it evaluates sizeof on an unsized struct array
before the array dimensions have been resolved from the initializer. The sema
const evaluator doesn't know about struct array flat initialization semantics,
so it gets the wrong element count.

Fix approach:
The lowerer should skip sema's pre-computed sizeof value for expressions that
reference unsized arrays whose sizes were determined by the initializer. When
eval_const_expr encounters a Sizeof expression, it should check if the sema
value is stale (i.e., if the array was unsized at sema time but sized by the
lowerer) and recompute if needed.

Expected impact:
- Fixes sizeof(cases)/sizeof(cases[0]) for unsized struct arrays with flat init
- This pattern is extremely common in C code (array element counting)
- Affects all three architectures
