Fix cfg_simplify comparison constant folding missing type truncation
=====================================================================
Status: in_progress
Date: 2026-01-28

Problem: The resolve_value_to_const_in_block function in cfg_simplify.rs
evaluates Cmp instructions with constant operands but ignores the `ty` field
of the Cmp instruction. It compares raw i64 values from to_i64() without
truncating them to the comparison type's width first.

This causes wrong results when comparing U32 values where one operand is
stored as IrConst::I32 (sign-extended to i64) and the other as IrConst::I64
(zero-extended). For example, IrConst::I32(-2) becomes i64 -2 (0xFFFF...FFFE)
while IrConst::I64(4294967294) stays as 4294967294 (0x0000...FFFE).
These represent the same 32-bit value but compare as different i64 values.

The constant_fold.rs pass already handles this correctly by calling
truncate_to_type() on both operands before comparing. The fix is to apply
the same truncation in cfg_simplify.rs.

Impact: Affects i686 and potentially other targets when U32 constants with
bit 31 set are compared. Multiple test failures in the i686 test suite.

Fix: Add type extraction and truncation in cfg_simplify.rs Cmp handler.
