Task: Fix label differences (&&lab1 - &&lab0) in static/global initializers

Problem:
When using computed goto with label differences in static initializers like:
  static int offsets[] = { &&lab1 - &&lab0, &&lab2 - &&lab0 };
the compiler silently produces zero values instead of actual label differences.
This pattern is used in Linux kernel BPF interpreter and computed-goto dispatch tables.

Root cause:
1. GlobalInit IR enum has no variant for label differences
2. eval_const_expr() has no case for Expr::LabelAddr - returns None
3. eval_global_addr_expr() doesn't handle LabelAddr subtraction
4. lower_global_init falls through to GlobalInit::Zero
5. Backend data emission has no label diff assembly directive

Fix plan:
1. Add GlobalLabelDiff(String, String) variant to GlobalInit enum in ir/ir.rs
2. In const_eval.rs: detect BinaryOp(Sub, LabelAddr(a), LabelAddr(b)) pattern
3. In global_init.rs: handle label diff expressions properly
4. In backend/common.rs: emit `.long .Lx - .Ly` assembly directives
5. Update has_addr_exprs to detect nested LabelAddr in binary ops

Failing tests:
- label-diff-static-init (ARM)
- gcc_torture_comp_goto_1 (x86, times out - uses label diff dispatch)
- Similar computed-goto dispatch tests
