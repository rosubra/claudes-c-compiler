Fix i686 sret call stack cleanup (caller double-cleaning ESP)

Status: in_progress

Problem:
When the i686 backend emits a call to a function that returns via sret (hidden pointer),
the callee pops the hidden pointer with `ret $4`. The caller must subtract 4 bytes from
its stack cleanup to compensate. However, the i686 override of emit_call() was NOT
subtracting these callee-popped bytes, causing ESP to be adjusted by 4 bytes too much
after the call. This led to subsequent push/pop instructions overwriting live stack data,
corrupting sret return buffers and causing incorrect results or crashes.

Root cause:
In i686/codegen/codegen.rs, the emit_call() override for non-fastcall calls duplicated
the trait's default emit_call logic but omitted the callee_pops_bytes_for_sret()
adjustment. The `is_sret` parameter was prefixed with underscore (`_is_sret`) and unused.

Fix:
Apply the same callee_pops_bytes_for_sret() subtraction that the default trait
implementation uses, so the caller only cleans up (stack_arg_space - 4) bytes
after an sret call.

Impact:
- Fixes complex type return tests (_Complex long double, _Complex double)
- Fixes struct-by-value return tests that use sret
- Fixes SIGSEGV crashes in tests with nested sret calls
- i686 unit test pass rate improved from 99.4% to 99.7% (9 additional tests passing)
- No regressions on x86-64, ARM, or RISC-V
