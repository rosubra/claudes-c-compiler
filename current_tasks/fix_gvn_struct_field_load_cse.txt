Fix GVN incorrectly CSE'ing struct field loads across different struct allocas

Problem:
The GVN (Global Value Numbering) pass incorrectly replaces struct field loads
with values from a different struct alloca when both structs have the same type.
This causes the comparison `n.cfg.width == 640 && n.cfg.height == 480 && n.id == 42`
to use wrong values when another struct array (configs[3]) of the same element type
is declared nearby.

Reproduction:
When a function contains:
1. Several Config structs (c, c2) with designated initializers
2. A Nested struct (n) containing a Config substruct
3. An array of Config structs (configs[3])
The GVN pass incorrectly reuses load results from one struct's fields for another,
even though they are different allocas.

Root cause:
GVN's load elimination or value numbering is not properly distinguishing between
loads from different allocas that happen to have the same struct type and field
offsets. The GetElementPtr + Load combination gets the same value number for
different base pointers.

Impact:
- Affects all three architectures (x86, ARM, RISC-V) since it's an IR-level bug
- Causes struct-init-designator-001 test to fail
- May cause other subtle correctness issues in programs with multiple same-type structs

Fix approach:
Review GVN's load elimination / value numbering for memory operations. Ensure
that loads from different base allocas are not treated as equivalent even when
the GEP offsets match.
