Task: Fix global variable initialization with address expressions

Problem:
Global variables initialized with address-of expressions are silently treated as
zero-initialized (placed in .bss), causing segfaults at runtime.

Examples that fail:
  int x = 5;
  int *p = &x;           // p ends up as NULL instead of &x
  void (*fp)(void) = f;  // function pointers not initialized
  int arr[5];
  int *q = arr;           // array-to-pointer decay not handled
  int *r = &arr[3];       // offset address expression not handled

Root cause:
In lower_global_init (lowering.rs), eval_const_expr does not handle AddressOf,
function name identifiers, or array names in global scope. It falls through to
GlobalInit::Zero.

Fix plan:
1. Extend lower_global_init to recognize Expr::AddressOf(Expr::Identifier(name))
   and emit GlobalInit::GlobalAddr(name) for simple address-of-global cases.
2. Handle function pointer initializers (identifier resolving to a function).
3. Handle array name decay to pointer (identifier resolving to an array global).
4. Add GlobalInit::GlobalAddrOffset(name, byte_offset) variant for expressions
   like &arr[3] or &s.field that need a known offset from a symbol.
5. Emit correct assembly in all three backends.
6. Add regression tests.

Affects: ~107+ failing tests with global pointer initialization patterns.
All three backends are equally affected (shared IR lowering bug).
