Fix expr_ctype_cache stale address reuse in typeof cast expressions

Status: completed

Bug: When lower_local_decl processes declarations with typeof or __auto_type,
it clones the declarators (decl.declarators.clone()). The cloned AST expression
nodes get cached in expr_ctype_cache (keyed by raw pointer address). When the
cloned declaration is dropped, the freed addresses get reused by new AST
allocations (e.g., typeof expressions in subsequent declarations). The stale
cache entries cause typeof(struct_ptr->field) to resolve as int instead of the
correct struct pointer type, leading to 32-bit loads (movslq) instead of
64-bit loads (movq) for pointer-typed struct members.

Fix: Clear expr_ctype_cache at the end of lower_local_decl when declarators
were cloned (typeof/auto_type path), preventing stale cache entries from
surviving past the lifetime of the cloned nodes.

Files modified:
- src/ir/lowering/stmt.rs (cache clear after cloned decl processing)
- tests/typeof-cast-stmtexpr-cache/ (regression test)
