Fix string literal "i" constraint resolution in inline assembly.

Problem: When a string literal is used as an "i" (immediate) constraint operand
in inline assembly (e.g., "i" ("file.c") in the kernel's BUG_ON/WARN_ON pattern),
the compiler fails to resolve it as an assembly-time constant. The string literal
address is valid for "i" constraints (it's a .rodata label known at link time),
but the compiler was treating it as a runtime value because:
1. eval_const_expr fails (strings aren't integer constants)
2. extract_symbol_name fails (strings aren't global variables or functions)
This left imm_symbol as None, making the "i" constraint "unsatisfiable."

When combined with .pushsection in the asm template, this caused the entire
inline asm block to be dropped, losing both the main instruction (e.g., ud2
for BUG_ON) and the metadata section (e.g., __bug_table).

Fix: In inline asm input lowering, when the expression is a string literal and
has an immediate constraint alternative, intern the string literal to get its
.rodata label and use that as the symbol name (imm_symbol). This makes the "i"
constraint satisfiable and the asm block is emitted correctly.

Files changed:
- src/ir/lowering/stmt.rs: Handle Expr::StringLiteral in "i" constraint path
