Task: fix_nested_bitfield_designator_array_init
Status: in_progress
Description: Fix nested bitfield designators in static/const struct array initializers.

Bug: When a struct with bitfield sub-members (like `.bits.type = 0xE`) was initialized
in an array context (static const struct idt_data arr[] = { { .bits.type = 0xE, .bits.p = 1, ...} }),
the bitfield values were silently lost. Only the last bitfield assignment took effect, and
it was written at the wrong bit position.

Root cause: DesignatorDrillResult (used by drill_designators) did not carry bit_offset/bit_width
from the final resolved StructFieldLayout. All callers that used drill_designators to resolve
nested designator chains like .bits.type passed None/None for bit_offset/bit_width to
write_expr_to_bytes_or_ptrs, causing bitfield writes to fall through to regular scalar writes.

Additionally, fill_multidim_struct_array_bytes had two code paths for [idx].field = val that
looked up the field in the layout but never checked field.bit_offset/bit_width before writing.

Fix:
1. Added bit_offset/bit_width fields to DesignatorDrillResult
2. Updated drill_designators to propagate bitfield metadata from the final resolved field
3. Updated fill_nested_designator_with_ptrs to pass bitfield info to write_expr_to_bytes_or_ptrs
4. Updated fill_nested_struct_with_ptrs likewise
5. Updated emit_compound_nested_designator_field to handle bitfield targets
6. Updated two [idx].field paths in fill_multidim_struct_array_bytes to use write_bitfield_to_bytes

Kernel impact: arch/x86/kernel/idt.c (IDT setup) was miscompiled, causing boot failure.
The struct idt_data uses nested bitfield designators (.bits.ist, .bits.type, .bits.dpl, .bits.p)
in a static const array. With this fix, idt.c compiles correctly and the kernel boots.

Files modified:
  - src/ir/lowering/global_init_bytes.rs
  - src/ir/lowering/global_init_compound.rs

Test: tests/nested-bitfield-designator-array/main.c
