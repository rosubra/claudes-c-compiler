Task: Extend x86 peephole copy propagation across entire basic blocks
Status: in_progress

Description:
The current propagate_register_copies pass only propagates movq %src, %dst
into the very next non-NOP instruction. This leaves thousands of redundant
register-to-register moves in generated code.

Profiling on DOOM binary: CCC produces 48,577 register-to-register mov
instructions vs 0 for GCC. CCC's R_DrawColumn (hottest rendering function) is
184 instructions vs 52 for GCC, largely due to these redundant copies.

Fix: Extend copy propagation to work across all instructions within a basic
block. After seeing movq %src, %dst, propagate dst->src replacement through
all subsequent instructions until:
1. A basic block boundary (label, jump, call, ret)
2. %src is overwritten (invalidates the copy)
3. %dst is overwritten (new definition)
4. An instruction with implicit register usage (div, mul, etc.)

Also: after propagation, if the movq instruction's destination has no more
uses within the block, the movq becomes dead and can be eliminated.

Files to modify:
- src/backend/x86/codegen/peephole/passes.rs
