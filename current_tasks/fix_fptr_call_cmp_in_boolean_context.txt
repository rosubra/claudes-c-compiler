Fix: function pointer call comparison in boolean context produces wrong result

Bug: When a function pointer call's return value is compared (e.g., > 0, < 0)
directly in a boolean context (if, &&, ||, ternary), the comparison result is
inverted/wrong. Assigning the return value to a variable first and then comparing
works correctly.

Example:
    typedef int (*fptr)(int, int);
    fptr compare = my_compare;

    // WRONG: compare(1, 3) returns -1, but this evaluates to 1 (true)
    if (compare(1, 3) > 0) { ... }

    // CORRECT:
    int r = compare(1, 3);
    if (r > 0) { ... }

Root cause: Likely in the IR lowering of comparison expressions on function
call results when used in a boolean/branch context. The codegen for short-circuit
evaluation or branch-on-comparison may be using wrong condition codes for the
call result.

Impact: Causes PostgreSQL initdb to PANIC because qsort_interruptible's insertion
sort produces wrong order, corrupting B-tree indexes during bootstrap.

Status: LOCKED
