Bug: goto cleanup double-emit causes kernel preempt_count corruption

Root cause: lower_goto_stmt() called collect_all_scope_cleanup_vars() which emits
cleanup calls for ALL active scopes. When goto jumps to a label in the SAME scope,
this causes double cleanup - once at the goto site, and again at the return statement.

In the Linux kernel, try_to_wake_up() uses guard(preempt)() which creates a cleanup
variable via __attribute__((cleanup)). When "goto out;" is executed:
  1. goto emits cleanup (preempt_enable) -> preempt_count goes from 1 to 0
  2. At "out:" label, return emits cleanup again -> preempt_count wraps to 0xFFFFFFFF
This causes "BUG: scheduling while atomic" and eventual kernel panic.

Fix: Added prescan_label_depths() to walk the AST before lowering and record each
label's scope depth. Updated lower_goto_stmt() to use
collect_scope_cleanup_vars_above_depth(target_depth) instead of
collect_all_scope_cleanup_vars(), so only scopes actually being exited are cleaned up.

Files changed:
- src/ir/lowering/stmt_control_flow.rs (added prescan functions, updated lower_goto_stmt)
- src/ir/lowering/func_state.rs (added user_label_depths field)
- src/ir/lowering/func_lowering.rs (wire up prescan call before lowering body)
