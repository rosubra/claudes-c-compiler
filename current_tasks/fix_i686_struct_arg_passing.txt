Task: Fix i686 struct byval argument passing for non-slot operands
Status: in_progress
Started: 2026-01-28

Problem:
In emit_call_stack_args, the StructByValStack and LargeStructStack cases
only handle operands that have a stack slot (via get_slot). If the struct
operand is a pointer in a register (e.g., address of a static/global
struct, or a register-allocated pointer), the copy is silently skipped,
leaving uninitialized data on the call stack.

This causes functions receiving struct arguments to read garbage values.

Fix:
When the operand doesn't have a stack slot, use operand_to_eax to load
the struct pointer into eax, then copy the struct data through the pointer
to the stack. This matches the x86-64 backend's approach.
