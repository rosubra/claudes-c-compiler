Fix global initialization of nested struct containing array of structs with pointer fields

Bug: When a global/static struct contains a member that is an array of structs,
and those inner structs have pointer fields (char *, function pointers, etc.),
the entire array member initialization is dropped (all zeros).

Example:
  struct Inner { const char *name; int val; };
  struct Outer { struct Inner items[2]; };
  static struct Outer o = { { { "x", 10 }, { "y", 20 } } };
  // Bug: o.items[0].name == NULL, o.items[0].val == 0 (all zeros)

The same array at global scope works fine:
  struct Inner arr[2] = { { "x", 10 }, { "y", 20 } };  // works correctly

And the same pattern without pointer fields in Inner also works fine:
  struct NoPtr { int a; int b; };
  struct Outer2 { struct NoPtr items[2]; };
  static struct Outer2 o2 = { { { 10, 20 }, { 30, 40 } } };  // works correctly

Root cause is likely in global_init_compound.rs where the struct-with-ptr-fields
init path doesn't correctly handle being nested inside another struct member.
