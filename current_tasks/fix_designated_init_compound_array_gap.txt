Fix designated initializer gap handling in compound init path

Status: in_progress

Problem:
When a struct containing pointer fields (requiring compound init path with
relocations) also has a scalar array field initialized with designated
initializers that have gaps (implicit zero-initialized elements between
explicitly initialized indices), the compiler was not emitting zeros for
the gap elements. Instead, it packed non-zero values contiguously,
corrupting the array and all subsequent struct members.

Example:
  struct inner { void *p; int data[8]; };
  struct outer { struct inner s; int after; };
  struct outer x = {
      .s = { .p = &something, .data = { [0]=3, [1]=3, [4]=1000 } }
  };
  // data[2] and data[3] should be 0 but contained 1000 and values
  // from later indices instead

Root cause:
Two functions used enumerate() to index into pre-zeroed byte buffers,
ignoring Designator::Index on initializer items:
1. fill_scalar_list_to_bytes() in global_init_bytes.rs
2. fill_scalar_array_with_ptrs() in global_init_compound_ptrs.rs

Impact:
This caused Linux kernel ARP to be completely broken when compiled with
ccc-x86, because arp_tbl.parms.data[] (struct neigh_parms) was corrupted,
shifting gc_thresh2/gc_thresh3 values to zero. This prevented ARP from
functioning, making all network communication via ping/wget impossible.

Fix:
Added designated initializer index tracking (current_idx with
Designator::Index parsing) to both functions, matching the pattern
already used correctly in lower_scalar_array_init() in global_init.rs.
