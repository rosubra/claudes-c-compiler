Fix ARM assembler: MSR/MRS system register op0 encoding off-by-two

Bug: When encoding `msr s<op0>_<op1>_<CRn>_<CRm>_<op2>, Xt`, the assembler
encodes op0 with an incorrect offset. For example:
  msr s0_3_c1_c0_1, x0  -> should produce d5031020 (wfit) but produces d5131020

This causes the kernel to hang during boot because __delay() calls the WFIT
instruction (op0=0) which our assembler incorrectly encodes as a different MSR.

The ARM64 MSR/MRS instruction encoding places op0 in bits[20:19], and the
s<op0>_... syntax should directly map the op0 value into these bits.
Our encoder appears to add 2 to op0 (treating it as 2+op0 range rather than 0-3).
