Fix x86 F128 store/load for computed pointers (GEP results)

Bug: emit_store and emit_load for F128 (long double) silently skip the operation
when resolve_slot_addr() returns None. This happens for computed pointers (e.g.,
GEP results like alloca+16 for the imaginary part of _Complex long double).

Result: the imaginary part of _Complex long double values gets corrupted (-nan)
when stored through computed pointers.

Fix:
1. Add fallback in emit_store for F128 when resolve_slot_addr returns None:
   load the pointer into rcx, then use fldl/fstpt sequence through (%rcx).
2. Same fix for emit_load for F128.
3. Also fix complex_zero() missing F128 branch (returns F64 instead of LongDouble).

This affects many complex long double tests across multiple test suites.
