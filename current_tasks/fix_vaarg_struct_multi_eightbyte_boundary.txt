Fix va_arg struct ABI: multi-eightbyte register/overflow boundary

Bug: When va_arg fetches a small struct (<=16 bytes) that needs multiple eightbytes
(GP and/or FP), the code emitted independent VaArg instructions for each eightbyte.
Each VaArg independently checked gp_offset/fp_offset, allowing a struct to straddle
the register/overflow boundary - with some eightbytes read from the register save
area and others from the overflow area.

Per the SysV AMD64 ABI, a multi-eightbyte argument must be passed entirely in
registers or entirely on the stack. The caller decides: if not enough registers for
all eightbytes, the whole struct goes to the stack.

Fix: Changed lower_va_arg_struct for x86-64 to use VaArgStruct for ALL structs
(not just >16 bytes). Added eightbyte_classes field to VaArgStruct IR instruction.
Added emit_va_arg_struct_ex to the backend trait (with default fallback).
Implemented x86 backend to atomically check if all GP and FP register slots
are available before choosing register or overflow path.

Tests fixed: c_testsuite_00204, compiler_suite_0081_0003 (+ 2 timeout fixes)
Test added: va-arg-struct-register-overflow-boundary
No regressions: 48/48 projects pass, 99.9% unit test pass rate
