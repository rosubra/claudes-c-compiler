Task: Fix dereferencing pointer-to-array from array arithmetic expressions
Status: IN PROGRESS

Problem: *(arr + N) where arr is a multi-dimensional array (e.g., int[2][3]) crashes
with a segfault. The issue is that get_expr_ctype for BinOp::Add propagates the raw
Array type instead of the decayed Pointer type, so lower_deref doesn't recognize the
expression as a pointer-to-array dereference and emits a Load instead of returning
the address directly.

Example:
  int arr[2][3] = {{1,2,3},{4,5,6}};
  int *p = *(arr + 1);  // CRASH - should give pointer to second row

Root cause: In get_expr_ctype for BinOp::Add, when lhs is Array(Array(Int, 3), 2),
it returns Array(Array(Int, 3), 2) directly. But in C, arr + 1 has type int(*)[3]
(pointer to array), because arrays decay in expression context. So get_expr_ctype
should return Pointer(Array(Int, 3)) for the Add expression.

Without this, lower_deref checks for CType::Pointer(Array(...)) but gets Array(Array(...))
and falls through to the Load path, which reads 8 bytes of array data as a pointer.

Fix: Decay array types to pointer-to-element in get_expr_ctype for pointer arithmetic.
Also add fallback in lower_deref for Array(Array(...)) case.

Expected impact: Fixes ~20+ pointer-to-array / array-decay test failures.
