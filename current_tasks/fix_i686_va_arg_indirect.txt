Task: Fix i686 va_arg when va_list is accessed through a pointer (va_list *)

Status: in_progress

Problem:
When va_arg is called with an indirectly-accessed va_list (e.g., va_arg(*args, int)
where args is va_list *), the i686 backend produces incorrect code.

The emit_va_arg codegen uses get_slot(va_list_ptr) to get the stack slot and loads
directly from it. This works for the direct case (local va_list variable) because
the slot IS the alloca that holds the va_list pointer. But for the indirect case
(va_list accessed through a pointer), the slot just holds the pointer-to-va_list
value, not the va_list itself. The code needs an extra level of indirection.

The fix needs to change emit_va_arg (and related emit_va_start, emit_va_copy) to
properly handle va_list_ptr as a generic pointer (not assuming it's always a local
alloca slot), loading through it with the correct number of indirections.

Affected tests: compiler_suite_0080_*, 0081_*, 0172_*, and potentially 0075_*
(all tests using va_list * or va_list passed by pointer).
