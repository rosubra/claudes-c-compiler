Lock: fix_x86_float_nan_comparison (in progress)

Task: Fix x86 float comparison NaN handling inconsistency

Problem:
The x86 emit_cmp for float types uses ucomisd/ucomiss which set CF=1, ZF=1, PF=1
when either operand is NaN. The current setcc instructions produce incorrect results:

- Eq: sete checks ZF=1 → returns 1 for NaN (WRONG, should be 0)
- Ne: setne checks ZF=0 → returns 0 for NaN (WRONG, should be 1)
- Lt/Ult: setb checks CF=1 → returns 1 for NaN (WRONG, should be 0)
- Le/Ule: setbe checks CF=1|ZF=1 → returns 1 for NaN (WRONG, should be 0)
- Gt/Ugt: seta → returns 0 for NaN (correct)
- Ge/Uge: setae → returns 0 for NaN (correct)

The C standard says comparisons with NaN return false (except !=).
ARM and RISC-V backends handle this correctly.

Fix approach:
- Eq: use sete + setnp (both must be true → AND them)
- Ne: use setne + setp (either true → OR them)
- Lt: use seta with reversed operand order (compare rhs, lhs)
- Le: use setae with reversed operand order
- Gt/Ge: already correct (seta/setae)

This matches standard GCC/LLVM codegen for ordered float comparisons.
