Fix i686 peephole DSE byte-range overlap bugs

Two bugs in the i686 dead store elimination peephole passes:
1. eliminate_dead_stores uses exact (offset, size) match instead of byte-range overlap
   when checking if a store is alive (has subsequent reads). This causes wide stores
   (e.g. movl for union.a) to be incorrectly eliminated when only narrow overlapping
   reads exist (e.g. movw for union.d.b at same offset).
2. eliminate_never_read_stores only tracks LoadEbp offsets, missing reads from
   folded memory operands (e.g. "cmpl -44(%ebp), %eax" classified as LineKind::Other).
   This causes stores to be eliminated even when they're read by folded instructions.

Both bugs are already fixed in the x86-64 backend via ranges_overlap() helper.
