Fix crealf/cimagf/creal/cimag intrinsics when called on non-complex scalar arguments

Problem: When crealf/creal/creall are called on non-complex scalar types (int, char, etc.),
the intrinsic returns the raw integer value without casting it to the appropriate float type.
For example, crealf(10) returns 0.0 instead of 10.0 because the integer 10 is returned as-is
but interpreted as F32 by the caller.

Similarly, when cimagf/cimag/cimagl are called on non-complex scalar integers, the returned
zero value should be in the appropriate float type, which it mostly handles but may have
edge cases.

The C standard says calling creal/crealf/creall on a non-complex value should:
1. Implicitly convert the scalar to the appropriate complex type
2. Then extract the real part (which is the converted scalar value)

This affects hundreds of test failures across tags:
- complex-to-integer (52/55 failing)
- type-mismatch (67/70 failing)
- data-loss (39/45 failing)
- complex-to-real (25/30 failing)
- real-part-extraction (44/64 failing)
- function-return-type (25/38 failing)

Fix: In the ComplexReal/ComplexImag intrinsic handlers, when the argument is not complex,
cast the value to the appropriate float type based on the function name (crealf->F32,
creal->F64, creall->F128).
