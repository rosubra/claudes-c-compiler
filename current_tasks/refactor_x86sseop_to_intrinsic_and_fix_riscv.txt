Refactor X86SseOp to target-independent IntrinsicOp and fix RISC-V backend bugs

The shared IR has an `X86SseOp` instruction with `X86SseOpKind` enum that names target-independent
concepts (fences, 128-bit loads/stores, byte comparisons, CRC32) using x86 terminology.
All three backends implement these operations using their native equivalents (x86 SSE, ARM NEON,
RISC-V scalar emulation). The naming is misleading.

Additionally, two RISC-V backend bugs exist:
1. `emit_rv_binary_128_bytewise` for Psubusb128 is an empty stub - silent wrong code
2. CRC32 operations return hardcoded 0 instead of computing the CRC

Plan:
1. Rename X86SseOp -> Intrinsic, X86SseOpKind -> IntrinsicOp throughout IR and all backends
2. Rename emit_x86_sse_op -> emit_intrinsic in the ArchCodegen trait and all implementations
3. Implement RISC-V Psubusb128 (unsigned saturating byte subtract via scalar emulation)
4. Implement RISC-V CRC32 via software CRC32C table lookup
5. Add regression tests

Status: LOCKED
