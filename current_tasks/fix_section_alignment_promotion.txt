Task: Fix section alignment promotion for custom-section globals

Problem: The compiler's effective_align() function promotes alignment to 16 for any
global variable with size >= 16 bytes. This is correct for standard sections (.data,
.bss) to match GCC/Clang behavior (enabling aligned SSE/NEON access), but incorrect
for globals placed in custom sections via __attribute__((section("..."))).

The Linux kernel's __param section contains tightly packed 40-byte struct kernel_param
entries with natural alignment 8. When the compiler promotes alignment to 16, the linker
inserts 8 bytes of padding at the boundary between GCC-compiled and CCC-compiled
__param contributions, corrupting the flat array. This causes a NULL pointer dereference
in parse_args() during early boot (kernel panic).

Fix: Skip alignment promotion for globals that have a custom section attribute
(g.section.is_some()). Also fix a secondary bug where .align for zero-initialized
custom-section globals was missing the ptr_dir.align_arg() wrapper (wrong on ARM/RISC-V).

Files modified:
- src/backend/common.rs: effective_align() checks g.section before promoting

Test: tests/section-align-no-promote/main.c

Status: in_progress
