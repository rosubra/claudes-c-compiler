Fix peephole optimizer store forwarding across inline asm (x86 kernel boot hang)

The x86 peephole optimizer's global_store_forwarding pass incorrectly forwards
register values across inline asm instructions that implicitly clobber registers.

Specific bug: The kernel's native_read_msr_safe() in apic.c uses inline asm with
"1: rdmsr ; xor %esi,%esi". The peephole optimizer doesn't recognize that rdmsr
implicitly clobbers eax:edx. It incorrectly replaces a subsequent stack slot load
"movq -40(%rbp), %rcx" with "movq %rax, %rcx" because it believes rax still holds
the value stored earlier. But rdmsr overwrote rax with the MSR low result, causing
the kernel to dereference a garbage pointer and hang during boot.

Fix: Mark lines containing ';' (multi-instruction), numeric labels with instructions
(like "1: rdmsr"), and specific privileged instructions (rdmsr, wrmsr, cpuid, rdtsc,
xgetbv) as having indirect memory access so that the store forwarding pass
invalidates all register mappings when encountering them.

Status: in_progress
