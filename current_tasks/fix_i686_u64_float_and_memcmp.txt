Fix i686 U64 unsigned-to-float conversion and __builtin_memcmp return type

Status: in_progress

Two i686 bugs fixed:

1. __builtin_memcmp return type: When the source doesn't include <string.h>,
   the fallback return type for LibcAlias builtins was I64, causing the i686
   backend to store both eax:edx as if it were a 64-bit return value. Since
   memcmp only sets eax, edx contained garbage, making 64-bit comparisons
   against 0 fail. Fixed by adding memcmp/strcmp/strncmp to builtin_return_type
   and using target_int_ir_type() as the fallback.

2. U64 unsigned-to-float conversion: The fildq instruction treats 64-bit values
   as signed. For unsigned values >= 2^63 (bit 63 set), fildq produces a
   negative result. Fixed by adding the shift-and-double technique: check if
   bit 63 is set, if so right-shift by 1 (preserving the lowest bit via OR
   for rounding), convert with fildq, then fadd st(0),st(0) to double.
   Applied to U64->F64, U64->F32, and U64->F128 paths.
   Also fixed the existing U64->F32 path which had a bug: it was OR-ing in
   bit 0 of the high word instead of bit 0 of the original low word.
