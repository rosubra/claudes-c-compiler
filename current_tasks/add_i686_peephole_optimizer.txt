Task: Add peephole optimizer to i686 backend
Status: in_progress

Problem:
The i686 backend has NO peephole optimizer, unlike the x86-64, AArch64, and
RISC-V backends which all have post-codegen peephole optimization. The raw
i686 assembly has massive redundancy:
- Redundant load/store pairs (store to stack, immediately load back)
- Self-moves (movl %eax, %eax)
- Dead stores (overwritten before read)
- Unnecessary jumps (jmp to next instruction)
- Missed compare+branch fusion

This causes i686 code to be 3-6x larger than GCC output, contributing to
the Linux kernel "Setup too big!" error for arch/x86/boot/ code.

Plan:
1. Create src/backend/i686/codegen/peephole.rs with i686-adapted peephole passes
2. Adapt core patterns from x86-64 peephole for 32-bit register names/sizes
3. Key passes: adjacent store/load elimination, self-move elimination,
   redundant jump elimination, dead store elimination, compare+branch fusion
4. Wire into i686 codegen output path in backend/mod.rs
5. Verify no regressions
