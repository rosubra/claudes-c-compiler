Fix VLA (Variable-Length Array) dynamic allocation and deallocation

Problem:
VLA declarations use static Alloca with a fixed compile-time size instead
of DynAlloca with the runtime-computed size. This means:
1. VLAs don't actually allocate the correct amount of memory at runtime
2. When control flow jumps backward past a VLA declaration (e.g., goto),
   the VLA's stack space is never reclaimed, causing stack overflow

Reproducer (from gcc_torture_vla_dealloc_1):
  int n = 0;
  if (0) { lab:; }
  int x[n % 1000 + 1];  // VLA allocated with static size, not n-dependent
  x[0] = 1;
  n++;
  if (n < 1000000) goto lab;  // Stack grows unboundedly -> timeout/crash

Fix plan:
1. Change VLA declaration lowering to use DynAlloca instead of Alloca
2. Add StackSave/StackRestore IR instructions for scope-based VLA lifetime
3. Emit StackSave before VLA declarations and StackRestore on scope exit
4. Handle backward gotos that cross VLA declarations by restoring stack
5. Implement codegen for StackSave/StackRestore on all 3 backends
