Task: Fix long double (F128) truthiness evaluation on x86
Status: in_progress

Problem:
Long double truthiness testing is broken on x86. The IR lowering uses bit-mask AND
with 0x7FFFFFFFFFFFFFFF (f64 sign-mask) on the F128 value to check for zero.
But for x87 80-bit long double, the low 8 bytes of the encoding are the mantissa
(not the f64 bit pattern). For 1.0L, the x87 mantissa is 0x8000000000000000, and
after AND-masking the sign bit, the result is 0x0000000000000000 = zero, making
1.0L appear falsy.

This causes:
- !1.0L returns 1 (should be 0)
- !0.0L returns 1 (should be 1) -- accidentally correct in some cases
- if(long_double_val) always false for many values (1.0, 2.0, 0.5, -1.0)
- Affects 5+ test cases in compiler_suite_0096_* and compiler_suite_0095_*

Fix plan:
1. In mask_float_sign_for_truthiness: For F128, emit a proper F128 comparison
   against zero (IrCmpOp::Ne) instead of bit-mask AND
2. In emit_bool_normalize_typed: Handle F128 zero constant properly
3. These changes are in the IR lowering layer, so they fix all architectures

Also investigating u64->long double conversion precision loss (separate issue,
both paths go through f64 intermediate which loses precision for large u64 values).
