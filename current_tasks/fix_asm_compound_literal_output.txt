Fix inline asm named operand substitution when output uses compound literal

Bug: When an inline asm output operand uses a compound literal expression
like `[tmp] "=&r"((long){0})`, the operand is skipped entirely during IR
lowering because `lower_lvalue` returns None for compound literals. This
causes named operand references like %[tmp] in the template to not be
substituted, producing assembler errors.

Fix: Create a temporary alloca for non-lvalue output expressions instead
of skipping them with `continue`. This preserves operand numbering and
allows named operand substitution to work correctly.

Affected: all backends (x86, ARM, RISC-V, i686)
