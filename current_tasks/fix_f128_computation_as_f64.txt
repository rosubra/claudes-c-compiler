Task: Fix F128 (long double) computation codegen on x86 and RISC-V
Status: IN PROGRESS

Problem: In x86 and RISC-V backends, F128 type operations (binop, unaryop, cmp, cast)
use F32 instructions instead of F64. This is because the code checks `ty == IrType::F64`
and F128 doesn't match, falling through to the else branch which assumes F32.

The ARM64 backend already handles this correctly by normalizing F128 to F64 at the top
of emit_cast_instrs. x86 and RISC-V need the same fix.

Affected functions in both x86 and RISC-V:
- emit_cast_instrs: F128 casts produce wrong instructions
- emit_binop: F128 uses F32 add/sub/mul/div instead of F64
- emit_unaryop: F128 neg uses F32 negation
- emit_cmp: F128 comparisons use F32 compare

Fix: Add F128->F64 normalization in all affected functions, treating F128 as F64
for all computation (since internally long double values are stored as f64 bit patterns).

Expected impact: ~74 long double test failures on x86, similar on RISC-V.
