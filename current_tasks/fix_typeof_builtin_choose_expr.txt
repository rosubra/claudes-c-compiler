Fix: __typeof(__builtin_choose_expr(...)) returns wrong type (int instead of correct branch type)

Problem:
  __typeof(__builtin_choose_expr(cond, expr1, expr2)) always resolves to CType::Int
  instead of the type of the selected branch expression. This is because the typeof
  code path treats __builtin_choose_expr as an ordinary function call and tries to
  look up its return type, which doesn't exist, so it falls back to CType::Int.

  This causes the Linux kernel's SYSCALL_DEFINE macros to malfunction. The kernel uses:
    __typeof(__builtin_choose_expr(__TYPE_IS_LL(t), 0LL, 0L)) a
  which should produce 'long' (8 bytes) but was producing 'int' (4 bytes).

  The result: syscall wrapper functions truncated 64-bit pointer and size arguments
  to 32 bits via movslq, breaking fundamental syscalls like read(), write(), etc.
  This caused kernel boot failures when fs/read_write.c was compiled with ccc.

Root cause:
  In type_checker.rs, infer_expr_ctype() for FunctionCall delegates to
  infer_call_return_ctype() which looks up __builtin_choose_expr as a regular
  function. Since it has no registered return type, the fallback is CType::Int.

  Similarly in lowering/expr_types.rs, get_expr_type() and get_expr_ctype_lowerer()
  for FunctionCall don't recognize __builtin_choose_expr as special.

  The actual compile-time branch selection only happens during try_lower_builtin_call()
  in expr_builtins.rs (value level), not at the type level.

Fix:
  1. In sema type_checker.rs: when infer_expr_ctype sees FunctionCall with
     __builtin_choose_expr, evaluate the condition via eval_const_expr and
     return the type of the selected branch (args[1] or args[2]).
  2. In lowering expr_types.rs: same fix in both get_expr_type() (IrType level)
     and get_expr_ctype_lowerer() (CType level).

Files changed:
  - src/frontend/sema/type_checker.rs
  - src/ir/lowering/expr_types.rs

Kernel bisect: fs/read_write.c now passes (was FAIL before fix).

Status: IN PROGRESS
