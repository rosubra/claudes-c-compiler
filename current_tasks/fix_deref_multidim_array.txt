Fix: Dereferencing multi-dimensional arrays (*arr where arr is 2D+ array)

Problem:
When a 2D array like `int x[2][3]` is dereferenced with `*x`, the compiler
incorrectly emits a Load instruction instead of treating it as an array decay
(just returning the address).

In C, `*x` on `int x[2][3]` yields `int[3]` (the first row), which decays to
`int*` â€” the same address as `x`. No load is needed.

Root cause in lower_deref (expr.rs): The pointee_is_aggregate check only handles
CType::Pointer(Array(...)) but not the raw CType::Array(Array(...), _) case.
When the inner expression is a raw array type (not yet decayed to pointer),
the check fails and a Load is emitted.

Also: get_array_base_addr and get_array_root_name_from_base in lvalue.rs do not
traverse through Expr::Deref nodes, so (*x)[i] patterns get wrong stride/element
size calculations.

Fix:
1. In lower_deref: Add handling for inner CType being Array(Array/Struct/Union, _)
   to avoid emitting a Load.
2. In get_array_base_addr: Add Expr::Deref case to properly compute base address
   when the base of a subscript is a dereference of a multi-dim array.
3. In get_array_root_name_from_base: Traverse through Deref nodes.

Tests affected: complex float array return, struct array access through deref,
general (*arr)[i] patterns on multi-dimensional arrays.
