Fix i686 bitfield operations using 64-bit (I64) shifts/masks instead of 32-bit (I32)
==================================================================================
Status: in_progress
Date: 2026-01-28

Problem:
- Bitfield extraction, storage, and truncation in expr_assign.rs unconditionally
  used IrType::I64 for all shift/mask operations, regardless of the target arch.
- On i686 with 32-bit storage types (I32/U32), this generated 64-bit operations
  (shrdl/shldl with eax:edx register pairs) instead of simple 32-bit shifts.
- The upper 32 bits of the widened value were often uninitialized, causing
  garbage data in bitfield reads on i686.

Fix:
- Use widened_op_type(storage_ty) instead of hardcoded IrType::I64 in all
  bitfield functions: extract_bitfield, extract_bitfield_from_addr,
  store_bitfield, store_bitfield_split, truncate_to_bitfield_value.
- On i686, this returns I32 for <=32-bit storage types, I64 for 64-bit storage.
- On 64-bit targets, this returns I64 (unchanged behavior).
- Shift amounts use op_bits (32 or 64) instead of hardcoded 64.

Files changed:
- src/ir/lowering/expr_assign.rs
