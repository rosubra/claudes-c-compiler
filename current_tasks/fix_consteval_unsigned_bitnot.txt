Fix constant expression evaluator: ~0u incorrectly evaluates to 64-bit all-ones

Problem:
- UIntLiteral values are stored as IrConst::I64 to preserve unsigned values
- When bitwise NOT (~) is applied, the result is 64-bit all-ones (-1 as i64)
- But ~0u should produce 0xFFFFFFFF (32-bit all-ones) since 0u is unsigned int
- This causes LZO's compile-time assertions to fail (56 errors)
- Also affects _Static_assert expressions and typedef array bounds

Root cause:
- eval_literal() stores UIntLiteral as I64(val as i64)
- bitnot_const(I64(0)) returns I64(!0) = I64(-1) = 0xFFFFFFFFFFFFFFFF
- But ~0u should be 0x00000000FFFFFFFF (32-bit width)

Fix: Make bitwise NOT in const evaluators aware of operand type width.
Both the parser-level eval_const_int_expr and sema-level SemaConstEval
need to truncate the bitwise NOT result to the operand's bit width.

Also need to fix comparison operations that compare unsigned values stored
as i64: (unsigned long)(-1) should compare as unsigned.
