Task: Fix F32 (float) codegen across all three backends

Problem:
All three backends have bugs in F32 (single-precision float) code generation.
The backends were written with F64 (double) as the primary float type, and F32
handling was added incompletely.

Issues to fix:

1. ARM backend - F32 binops use F64 instructions (fadd d0 instead of fadd s0)
2. ARM backend - F32 unary neg uses d0 instead of s0
3. ARM backend - F32 comparisons use d0/d1 instead of s0/s1
4. ARM backend - F32 return value uses d0 instead of s0
5. ARM backend - F32 call args use fmov to d-regs for F32 when s-regs needed
6. x86 backend - F32 unary neg uses F64 sign bit mask (0x8000000000000000 instead of 0x80000000)
7. RISC-V backend - F32 return value uses fmv.d.x instead of fmv.w.x
8. RISC-V backend - F32 parameter storage uses fmv.x.d instead of fmv.x.w

Fix approach:
- In each backend, add F32/F64 branching where needed
- ARM: Use s0/s1 registers and F32 instructions for F32 types
- x86: Use correct sign bit mask for F32 negation
- RISC-V: Use fmv.w.x/fmv.x.w for F32 types

Status: In progress
