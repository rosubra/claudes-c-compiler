Fix i686 peephole: cmpxchg8b implicit register uses not modeled

Bug: The i686 peephole optimizer's dead register move elimination pass
removes `movl %edx, %ecx` before `lock cmpxchg8b`, because it doesn't
recognize that cmpxchg8b implicitly reads eax, edx, ecx, and ebx.

Root cause: implicit_reg_use() in peephole.rs handles cltd, idiv, imul,
div, mul, rep, loop, but NOT cmpxchg8b. Since cmpxchg8b mentions no
register operands in its text (only the memory operand), line_references_reg()
returns false for ecx, ebx, eax, and edx.

Symptom: __atomic_compare_exchange for 64-bit types on i686 corrupts the
upper 32 bits of the stored value, because ecx (desired_high) contains
garbage instead of the intended value.

Fix: Add cmpxchg8b handling to implicit_reg_use() - it uses eax, edx,
ecx, and ebx. Also handle cmpxchg (without 8b) which uses eax.

Started: 2026-02-05
