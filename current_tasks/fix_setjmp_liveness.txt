Task: Fix setjmp/longjmp liveness analysis causing mquickjs x86 crash

Problem: The liveness analysis in the register allocator does not account for
setjmp's "returns twice" semantics. Values that are live at the setjmp call
point may have their stack slots reused by code between the initial return (0)
and the longjmp return. When longjmp restores the stack frame, these values
contain stale data, causing corruption.

Root cause: GEP simplification reduces the number of live values, changing
register allocation so that critical values (e.g. saved_sp, saved_top_gc_ref)
are spilled to stack slots instead of callee-saved registers. These stack slots
get clobbered between setjmp and longjmp.

Fix: Extend live intervals of all values that are live-in or live-out of blocks
containing setjmp/_setjmp/sigsetjmp/__sigsetjmp calls to span the entire
function, preventing their stack slots from being reused.

Status: completed
